---
title: "Primeira Lista de Exercícios"
author: Lara de Andrade Oliveira
header-includes:
  - \usepackage{indentfirst}
  - \setlength{\parindent}{20pt}
output:
  pdf_document: default
  html_document: default
date: '25-09-2022'
fontsize: 12pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
setwd("C:/Users/Lara/Documents/OI")
library(dplyr)
library(stringr)
library(stargazer)
library(knitr)
library(kableExtra)
library(ivreg)
library(ggplot2)
library(data.table)
library(BLPestimatoR)
```

```{r, include=FALSE}
#abrindo a base de dados
carros <- read.csv("fipefenabrave1.csv", header = FALSE) %>%
  rename(ano_ref = V1, marca = V2, modelo = V3, descmodelo = V4, preco = V5, quantidade = V6, combustivel = V7, cc = V8, ipi = V9) %>% 
  mutate(cambio = case_when(
                    str_detect(descmodelo, "Aut") ~ "Automatico",
                    str_detect(descmodelo, "Mec") ~ "Mecanico",
                    TRUE ~ NA_character_),
        portas = str_extract(descmodelo, "\\dp") %>% 
                   str_remove("p") %>% 
                   as.numeric()
        )

preco_base <- read.csv2("preco_base.csv", header = TRUE)
preco_base <- subset(preco_base, select = - ano_ref)

carros <- cbind(carros, preco_base)

#função de moda
getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

#criando base agregada
carros_agregado <- carros %>%
  group_by(modelo, ano_ref, marca) %>%
  summarize(preco=mean(preco, na.rm = TRUE), quantidade=sum(quantidade, na.rm = TRUE), combustivel=getmode(combustivel), cc=mean(cc, na.rm = TRUE), ipi=mean(ipi,na.rm = TRUE), cambio=getmode(cambio), portas=getmode(portas), preco_base=mean(preco_base, na.rm = TRUE))
carros_agregado <- carros_agregado[, c(2,3,1,4,5,6,7,8,9,10,11)]
```


# Exercício 1

Ao desagregar os dados ao nível de submodelos, estamos impondo que as vendas são distribuídas entre os submodelos igualmente  (já que não temos os dados de quantidade por submodelo). Isso pode introduzir um erro de medida, já que é esperado que modelos mais completos sejam mais caros e, portanto, vendam menos do que os modelos mais baratos. Assim, ao dar a todos os modelos a mesma quantidade, podemos estar subestimando as vendas dos modelos mais baratos e sobrestimando as do modelos mais caros. Isso acarretaria em um viés de atenuação.  
  
Além disso, perdemos as variações de venda entre cada submodelo dadas as características como combustível, portas, câmbio e cilindradas. Isso pode levar a demandas mais inelásticas dentro de cada modelo.  
  
Outra opção é estimar um modelo agregado ao nível do modelo, porém essa pode não ser também a melhor opção porque perderíamos muitas observações (de mais de 4300 para cerca de 500). Além disso, ao agregar todos os submodelos no mesmo modelo, podemos ter erros dependendo de qual "regra" usarmos para agregar as características. Por exemplo, dentro de um mesmo modelo, podemos ter submodelos com diferentes cilidradas e número de portas, nesse caso qual é o melhor a se fazer: usar a moda de cada característica ou a média (quando for uma característica numérica)?  
  
Vamos analisar melhor cada um desses casos nos próximos exercícios.
  
# Exercício 2  
  
A omissão dos carros menos vendido pode gerar um problema, já que no modelo de escolha discreta assumimos que ou o indivíduo compra um carro ou nenhum, que é considerado um outside good. Como a base não considera os carros menos vendidos, eles seriam considerados dentro do outside good.  
  
Dessa forma, perdemos a variação desses carros caso eles sejam substitutos dos carros que estão na base, de modo que um aumento no preço do carro que esta na base poderia levar a um aumento na quantidade vendida do carro que está fora, mas, como é considerado outside good, perderíamos essa variação.  
  
No entanto, talvez esse não fosse um problema tão procupante caso os 50 carros mais vendidos já representassem uma parcela significativa de todos os carros, de forma que os carros que se juntam ao outside good não teriam muito efeito sobre a demanda dos demais que estão na base.  
Já na estimação logit, caso os 50 mais vendidos não sejam parte significativa do total, poderíamos ter uma superestimação da elasticidade cruzada entre os carros popularese  o outside good.  
  
Esse problema também aparece em Nevo (2001), que só dispunha das 25 marcas mais vendidas. Nesse caso, não são encontrados estimadores de sensibilidade de preço que são viesados. Porém, o caso de Nevo (2001) e o nosso são de mercados completamente diferentes, de modo que é possível que nesse trabalho encontremos problemas.
  
# Exercício 3  
  
Para conseguir a informação sobre quantas pessoas não compram carros, podemos pegar o tamanho do mercado. Seguindo o método utilizado no BLP(1995), podemos usar o total de domicílios no país como estimativa.  
  
Já que temos dados dos carros vendidos entre 2003 e 2016, podemos usar os dados da Pnad para pegar o total de domicílios entre 2003-2009, 2011-2015. Os dados de 2010 são do censo e  de 2016 da PnadC.  
  
O cálculo do outside good é feito portanto da seguinte forma:  
  
$$outside good = domicílios_t - \sum_tvendas_t$$  
onde $domicilios_t$ é o número de domicílios no ano $t$ e $\sum_tvendas_t$ é o número total de venda de carros no ano $t$.  
  
Os resultados estão descritos na tabela 1.
  
```{r, echo=FALSE}
#base dos domicílios
dom <- read.csv("domicilios.csv", sep = ";")

#vendas por ano
carros_ano <- carros %>%
  group_by(ano_ref) %>%
  summarize(quantidade = sum(quantidade))

#juntando as duas bases
car_dom_ano <- merge(carros_ano, dom, by = "ano_ref")
car_dom_ano$outside <- car_dom_ano$domicilios-car_dom_ano$quantidade

#tabela
kable(car_dom_ano, col.names = c("", "Vendas", "Domicílios", "Outside Good"), caption = "Mercado de Automóveis") %>%
  kable_styling(latex_options = "hold_position")

```

# Exercício 4  
  
```{r,echo=FALSE, results='asis'}

#market shares
##outisde good
car_dom_ano$s0 <- car_dom_ano$outside/car_dom_ano$domicilios

aux <- subset(car_dom_ano, select = - c(quantidade, outside, s0))

##submodelos
carros <- left_join(carros, aux, by="ano_ref")
carros$sj <- carros$quantidade/carros$domicilios
carros <- subset(carros, select = -domicilios)

aux <- subset(car_dom_ano, select = -c(quantidade, outside, domicilios))
carros <- left_join(carros, aux, by = "ano_ref")

#log(sj)-log(s0)
carros$y <- log(carros$sj)-log(carros$s0)

#rodando o logit
car_logit <- subset(carros, select = - c(s0, sj))
car_logit$preco_base = car_logit$preco_base/1000
car_logit$gasolina <- ifelse(car_logit$combustivel=="Gasolina", 1, 0)
car_logit$diesel <- ifelse(car_logit$combustivel=="Diesel", 1, 0)
car_logit$flex <- ifelse(car_logit$combustivel=="Flex", 1, 0)
car_logit$automatico <- ifelse(car_logit$cambio=="Automatico", 1, 0)
car_logit$automatico[is.na(car_logit$automatico)] <- 0
car_logit$dportas <- ifelse(car_logit$portas<4, 1, 0)
car_logit$dportas[is.na(car_logit$dportas)] <- 0
```

  
O modelo logit a ser estimado é  
$$ln(s_j) - ln(s_0)=\alpha Preco_j+\beta X_j+\epsilon_j$$ onde $X_j$ é um vetor de caracterísitcas do produto.    
   
Além das características já listada na base, foram incluídas dummies para o tipo de combustível (gaslina, diesel, flex e álcool), cambio (automático ou mecânico), marca e número de portas (aqui, há diferença em como cada marca reporta o número de portas, algumas considerando o porta-malas e outras não, de modo que alguns carros podem ter 3 ou 5 portas. Assim, para montar as dummies, considerei que um carro com 3 portas é um carro com 2 portas e um de 5 portas é de 4 portas). Os resultados estão na Tabela 2 abaixo.  
  
Os coeficientes de preço são negativos em todos os modelos, conforme pervê a teoria da demanda, no entanto parece estranho o coeficiente de cilindradas ser negativo, assim como o de Automático, uma vez que esperamos que essas seriam características preferidas pelos consumidores.
  
```{r, echo=FALSE, results='asis'}

#regredindo os modelos
logit_1 <- lm(y~preco_base+gasolina+diesel+flex+cc, data = car_logit)
logit_2 <- lm(y~preco_base+gasolina+diesel+flex+cc+automatico, data = car_logit)
logit_3 <- lm(y~preco_base+gasolina+diesel+flex+cc+dportas, data = car_logit)
logit_4 <- lm(y~preco_base+gasolina+diesel+flex+cc+automatico+dportas+factor(marca), data = car_logit)

m1 <- stargazer(logit_1, logit_2, logit_3, logit_4, type="latex",  dep.var.labels=c("ln(sj)-ln(s0)"),
covariate.labels=c("Preço", "Gasolina", "Diesel", "Flex", "Cilindradas", "Automatico", "2 Portas"), omit = "marca",  add.lines = list(c("Dummies de Marca", "Não", "Não", "Não", "Sim")), title = "Demanda Logit", header = FALSE, table.placement = "H", omit.stat = c("f", "ser"))

```
  
    
Podemos fazer também o mesmo modelo porém considerando os dados agregados. Aqui, utilizamos a média dos preços, das cilidradas e do ipi e a moda dos combustíveis, do câmbio e das portas. Com a agregação perdemos modelos que utilizem o álcool, assim, a dummy aqui omitida é de carro flex.  
  
Como no modelo desagregado, o coeficiente dos preços continua negativo, como era esperado, no entanto o coeficiente para Automático deixa de ser significativo e o de Cilindradas continua negativo. Ou seja, o modelo agregado não parece dar estimativas melhores.   
  

```{r, echo=FALSE, results='asis'}
#montando o df agregado
aux <- subset(car_dom_ano, select = - c(quantidade, outside, s0))

carros_agregado <- left_join(carros_agregado, aux, by = "ano_ref")
carros_agregado$sj <- carros_agregado$quantidade/carros_agregado$domicilios
carros_agregado <- subset(carros_agregado, select = -domicilios)


aux <- subset(car_dom_ano, select = - c(quantidade, outside, domicilios))
carros_agregado <- left_join(carros_agregado, aux, by = "ano_ref")


carros_agregado$y <- log(carros_agregado$sj)-log(carros_agregado$s0)


#logit agregado
car_logit_a <- subset(carros_agregado, select = - c(s0, sj))
car_logit_a$preco_base = car_logit_a$preco_base/1000
car_logit_a$gasolina <- ifelse(car_logit_a$combustivel=="Gasolina", 1, 0)
car_logit_a$diesel <- ifelse(car_logit_a$combustivel=="Diesel", 1, 0)
car_logit_a$flex <- ifelse(car_logit_a$combustivel=="Flex", 1, 0)
car_logit_a$automatico <- ifelse(car_logit_a$cambio=="Automatico", 1, 0)
car_logit_a$automatico[is.na(car_logit_a$automatico)] <- 0
car_logit_a$dportas <- ifelse(car_logit_a$portas<4, 1, 0)
car_logit_a$dportas[is.na(car_logit_a$dportas)] <- 0

#rodando os modelos
logit_a_1 <- lm(y~preco_base+gasolina+diesel+cc, data = car_logit_a)
logit_a_2 <- lm(y~preco_base+gasolina+diesel+cc+automatico, data = car_logit_a)
logit_a_3 <- lm(y~preco_base+gasolina+diesel+cc+dportas, data = car_logit_a)
logit_a_4 <- lm(y~preco_base+gasolina+diesel+cc+automatico+dportas+factor(marca), data = car_logit_a)

m2 <- stargazer(logit_a_1, logit_a_2, logit_a_3, logit_a_4, type="latex",  dep.var.labels=c("ln(sj)-ln(s0)"),
covariate.labels=c("Preço", "Gasolina", "Diesel", "Cilindradas", "Automatico", "2 Portas"), omit = "marca",  add.lines = list(c("Dummies de Marca", "Não", "Não", "Não", "Sim")), title = "Demanda Logit no Modelo Agregado", header = FALSE, table.placement = "H", omit.stat = c("f", "ser"))

```

  
# Exercício 5  
  
Vamos utilizar o IPI como instrumento para o preço. Para que ele seja um instrumento válido, precisa satisfazer duas condições: a condição de relevância e de exclusão. A condição de relevância pode ser testada pelo primeiro estágio da regressão (apresentado abaixo). Já a restrição de exclusão, para ser válida, precisamos que o IPI seja não correlacionado com o erro, ou seja, ele deve afetar a demanda somente por meio do preço, e não diretamente. Parece razoável supor que essa condição é válida, já que o aumento do imposto deve afetar o custo marginal do produto, não impactando a demanda diretamente.  
  
Vamos primeiro analisar o primeiro estágio, ou seja, vamos regredir o preço no IPI e nas demais variáveis que estávamos usando para compor cada modelo. Os resultados estão apresentados na tabela 4.  
  
Como esperado, Automático e Cilidradas têm coeficientes positivos e significantes. O coeficiente de IPI no preço também é significante em todos os modelos, porém parece estranho o sinal dele ser negativo. Isso pode ser devido ao fato de que, em vários anos, houve isenção do IPI. De qualquer forma, podemos concluir que IPI parece ser um bom instrumento por ser relevante e cumprir a restrição de exclusão. Agora podemos estimar o 2SLS.
  
```{r, echo=FALSE, results='asis'}

#calculando o modelo agora com ipi como instrumento para o preço

##primeiro estágio

fs1 <- lm(preco_base~ipi+gasolina+diesel+flex+cc, data = car_logit)
fs2 <- lm(preco_base~ipi+gasolina+diesel+flex+cc+automatico, data = car_logit)
fs3 <- lm(preco_base~ipi+gasolina+diesel+flex+cc+dportas, data = car_logit)
fs4 <- lm(preco_base~ipi+gasolina+diesel+flex+cc+automatico+dportas+factor(marca), data = car_logit)

iv1 <- stargazer(fs1, fs2, fs3, fs4, type = "latex", dep.var.labels=c("Preço"),
covariate.labels=c("IPI", "Gasolina", "Diesel", "Flex", "Cilindradas", "Automatico", "2 Portas"), omit = "marca",  add.lines = list(c("Dummies de Marca", "Não", "Não", "Não", "Sim")), title = "Primeiro Estágio", header = FALSE, table.placement = "H", omit.stat = c("f", "ser"))

```
  
Os resultados do 2SLS estão apresentados na tabela 5. Aqui já não temos o que é esperado pela lei da demanda: os preços apresentam coeficiente positivo e todos os demais regressores aparecem com coeficientes negativos. Vamos estimar também para a base agregada para ver se os resultados parecem fazer mais sentido.  

```{r, echo=FALSE, results='asis'}

##rodando o iv

m_iv1 <- ivreg(y~preco_base+gasolina+diesel+flex+cc | ipi+gasolina+diesel+flex+cc, data = car_logit)
m_iv2 <- ivreg(y~preco_base+gasolina+diesel+flex+cc+automatico | ipi+gasolina+diesel+flex+cc+automatico, data = car_logit)
m_iv3 <- ivreg(y~preco_base+gasolina+diesel+flex+cc+dportas | ipi+gasolina+diesel+flex+cc+dportas, data = car_logit)
m_iv4 <- ivreg(y~preco_base+gasolina+diesel+flex+cc+automatico+dportas+factor(marca) | ipi+gasolina+diesel+flex+cc+automatico+dportas+factor(marca), data = car_logit)

iv2 <- stargazer(m_iv1, m_iv2, m_iv3, m_iv4, type = "latex", dep.var.labels=c("ln(sj)-ln(s0)"),
covariate.labels=c("Preço", "Gasolina", "Diesel", "Flex", "Cilindradas", "Automatico", "2 Portas"), omit = "marca",  add.lines = list(c("Dummies de Marca", "Não", "Não", "Não", "Sim")), title = "Regressão IV", header = FALSE, table.placement = "H", omit.stat = c("f", "ser"))

```
  
Começamos novamente pelo primeiro estágio (Tabela 6). Agora o coeficiente do IPI aparece positivo, o que parece fazer mais sentido e os coeficientes de Cilidradas e Câmbio Automático têm sinal positivo (com excessão do último modelo, onde Automatico aparece negativo, porém não significante).     

```{r, echo=FALSE, results='asis'}
#para o modelo agregado

##primeiro estágio
fs1_a <- lm(preco_base~ipi+gasolina+diesel+cc, data = car_logit_a)
fs2_a <- lm(preco_base~ipi+gasolina+diesel+cc+automatico, data = car_logit_a)
fs3_a <- lm(preco_base~ipi+gasolina+diesel+cc+dportas, data = car_logit_a)
fs4_a <- lm(preco_base~ipi+gasolina+diesel+cc+automatico+dportas+factor(marca), data = car_logit_a)

iv3 <- stargazer(fs1_a, fs2_a, fs3_a, fs4_a, type = "latex", dep.var.labels=c("Preço"),
covariate.labels=c("IPI", "Gasolina", "Diesel", "Cilindradas", "Automatico", "2 Portas"), omit = "marca",  add.lines = list(c("Dummies de Marca", "Não", "Não", "Não", "Sim")), title = "Primeiro Estágio do Modelo Agregado", header = FALSE, table.placement = "H", omit.stat = c("f", "ser"))
```

Os resultados do 2SLS para o modelo agregado estão na tabela 7. O preço apresenta coeficiente negativo, o que é condizente, e também obtemos resultados positivos e significantes para Cilindradas e Automatico, novamente com excessão do último modelo, quando incluímos todos os controles e dummies de marca. Portanto, os resultados com IV parecem fazer mais sentido, de forma que é possível que o viés estivesse atrapalhando nossos resultados anteriores. 
  
```{r, echo=FALSE, results='asis'}

##iv
ma_iv1 <- ivreg(y~preco_base+gasolina+diesel+cc|ipi+gasolina+diesel+cc,data=car_logit_a)
ma_iv2 <- ivreg(y~preco_base+gasolina+diesel+cc+automatico|ipi+gasolina+diesel+cc+automatico,data=car_logit_a)
ma_iv3 <- ivreg(y~preco_base+gasolina+diesel+cc+dportas|ipi+gasolina+diesel+cc+dportas,data=car_logit_a)
ma_iv4 <- ivreg(y~preco_base+gasolina+diesel+cc+automatico+dportas+factor(marca)|ipi+gasolina+diesel+cc+automatico+dportas+factor(marca),data=car_logit_a)

iv4 <- stargazer(ma_iv1, ma_iv2, ma_iv3, ma_iv4, type = "latex", dep.var.labels=c("ln(sj)-ln(s0)"),
covariate.labels=c("Preço", "Gasolina", "Diesel", "Cilindradas", "Automatico", "2 Portas"), omit = "marca",  add.lines = list(c("Dummies de Marca", "Não", "Não", "Não", "Sim")), title = "Regressão IV com dados Agregados", header = FALSE, table.placement = "H", omit.stat = c("f", "ser"))
```

# Exercício 6  
  
Vamos computar agora as elasticidades-preço da demanda:  
  
$$\frac{\partial{log(s_j)}}{\partial{p_i}}=\frac{\partial(\delta_j-log(\sum_{i=0}^{J}e^{\partial_j}))}{\partial p_j}= \begin{cases} \frac{-(-\alpha)e^{\delta_i}}{\sum e^{\delta_i'}}=\alpha s_i & \text { se j} \neq \text {i} \\ -\alpha+\frac{\alpha e^{\delta_j}}{\sum e^{\delta_j}}=-\alpha(1-s_j) & \text {se j = i} \end{cases}$$
Assim,

$$\eta_{ij}=\begin {cases} \alpha s_ip_j & \text{se j} \neq \text{i}\\ -\alpha p_j(1-s_j) & \text{se j=i} \end{cases}$$
  
Os resultados estão apresentados nas tabelas abaixo. Para a elasticidade cruzada foi usado o ano de 2016 e o gráfico capta o efeito de que a elasticidade aumenta com as vendas (e portanto com o sj), mostrando uma relação aproximadamente linear.
  
```{r,echo=FALSE, fig.pos="H"}

#calculando a elaticidade do gol em relação ao próprio preço - usando a tabela agregada

alpha <- ma_iv4$coefficients["preco_base"]

elast_gol <- filter(carros_agregado, modelo == "GOL")
elast_gol$elasticidade <- alpha*(1-elast_gol$sj)*elast_gol$preco_base/1000
elast_gol <- subset(elast_gol, select = c(ano_ref, elasticidade))

kable(elast_gol, col.names = c("Ano", "Elasticidade"), caption = "Elasticidade-Preço da Demanda - Gol") %>%
  kable_styling(latex_options = "hold_position")

#calculando a elasticidade cruzada

elast_cruz <- filter(carros_agregado, ano_ref == 2016)
elast_cruz$elasticidade <- -alpha*elast_cruz$sj*elast_cruz$preco_base[elast_cruz$modelo=="GOL"]/1000
elast_cruz <- subset(elast_cruz, modelo!="GOL",select = c(modelo, quantidade,elasticidade))

kable(elast_cruz, col.names = c("Modelo", "Vendas", "Elasticidade"), caption = "Elasticidade-Cruzada da Demanda - Gol (2016)") %>%
  kable_styling(latex_options = "hold_position")

```


\clearpage
```{r, echo=FALSE}

#gráfico
ggplot(elast_cruz, aes(x=quantidade, y=elasticidade)) + geom_point() + labs(
  title = "Figure 1: Elasticidade x Quantidade",
  subtitle = "2016",
  x = "Quantidade vendida",
  y = "Elasticidade"
) + theme_bw()

```
  
  
  
# Exercício 7  
  
Para calcular o custo marginal vamos utilizar o método utilizado no BLP, que é  dado da seguinte forma: $$\Pi=max_{p_j}\sum_{j\in{J_f}}(p_j-mc_j)M_{s_j}$$  
  
Assim, os produtos da firma f terão um preço que satisfaça a seguinte condição de primeira ordem: $$s_j+\sum_{r\in{J_f}}(p_r-mc_r)\frac{\partial{s_r}}{\partial{p_j}}=0$$  
  
Dessa forma, as J condições de primeira ordem implicam um mark-up de $(p_j-mc_j)$ para cada bem. Como no BLS (95) foi definida uma matriz $\Delta$ $J$ por $J$ onde os elementos são dados por: $$\Delta_{jr}=\begin{cases}-\frac{\partial{s_r}}{\partial{{p_j}}} & \text { se r e y são produzidos pela mesma firma} \\ 0 & \text {caso contrário}\end{cases}$$ 
  
Em termos matriciais temos que: $$s(p,x, \xi;\theta)-\Delta(p,x,\xi;\theta)[p-mc]=0$$  
  
Assim, podemos estimar o custo marginal da seguinte forma: $$mc=p-\Delta(p,x,\xi;\theta)^{-1}s(p,x,\xi;\theta)$$  
  
A matriz $\Delta$ é dada da seguinte forma: na diagonal, os valores são dados por $-\alpha (s_j-s_j^2)$, $\alpha s_js_k$ quando são da mesma marca e 0 caso contrário. 
  
Os resultados para Custo Marginal e Markups (utilizando a base agregada) para o ano de 2016 estão na tabela 10. Os resultados implicam que, quanto menor é o preço, menores são as elasticidades em relação ao próprio preço, menores são os custos marginais e maiores os markups. Esse problema também aparece em BLP(95), e pode ocorrer porque há baixa variação em $\Delta(p,x,\xi;\theta)^{-1}s(p,s,\xi;\theta)$.  
    
\clearpage    
```{r, echo=FALSE}

#construindo matriz delta
elast_aux <- filter(carros_agregado, ano_ref == 2016)
elast_aux$elasticidade <- -alpha*elast_aux$sj*elast_aux$preco_base[elast_aux$modelo == "GOL"]/1000
elast_aux <- subset(elast_aux, select = c(modelo, marca, preco_base, sj,  elasticidade))
mat <- matrix( 0, ncol = length(elast_aux$modelo), nrow=length(elast_aux$modelo))
colnames(mat) <- c(elast_aux$modelo) 
rownames(mat) <- c(elast_aux$modelo)

#alpha auxiliar
car_logit_a$preco_base <- car_logit_a$preco_base*1000
ma_iv4_aux <- ivreg(y ~ preco_base + gasolina + diesel + cc + automatico + dportas + factor(marca) | ipi + gasolina + diesel + flex + cc + automatico + dportas + factor(marca), data = car_logit_a)
alpha_aux <- ma_iv4_aux$coefficients["preco_base"]

#montando a matriz
i <- 1
j <- 1
nrow <- length(elast_aux$modelo)
ncol <- length(elast_aux$modelo)
names <- rownames(mat)
while (i <= nrow) {
  while (j <= ncol) {
    mat[i,j] <- if_else(i == j, -alpha_aux*(setDT(elast_aux, key = 'modelo')[names[i], .(sj = sj[1])]$sj - (setDT(elast_aux, key = 'modelo')[names[i], .(sj = sj[1])]$sj)^2), if_else(setDT(elast_aux, key = 'modelo')[names[i], .(marca = marca[1])]$marca == setDT(elast_aux, key = 'modelo')[names[j], .(marca = marca[1])]$marca, alpha_aux*setDT(elast_aux, key = 'modelo')[names[i], .(sj = sj[1])]$sj*setDT(elast_aux, key = 'modelo')[names[j], .(sj = sj[1])]$sj, 0))
    j <- j + 1
  }
  i <- i + 1
  j <- 1
}

#calculando os custos marginais
elast_aux$cm <- elast_aux$preco_base - solve(mat) %*% elast_aux$sj
elast_aux$markup <- (elast_aux$preco_base-elast_aux$cm)/elast_aux$preco_base

elast_aux <- subset(elast_aux, select = -elasticidade)

kable(elast_aux, col.names = c("Modelo", "Marca", "Preço", "Sj", "CMg", "Markup"), caption = "Custo marginal dos modelos de automóveis (2016)") %>%
  kable_styling(latex_options = "hold_position")

```

# Exercício 8  
  
O modelo origianl utilizado em BLP (95) é: $$u_{i j t}=x_{j t} \bar{\beta}+\xi_{j t}+\alpha \ln \left(y_{i}-p_{j}\right)+\sum_{k} \sigma_{k} x_{j t k} v_{i k}+\epsilon_{i j t}$$  
  
No entanto, como não temos dados de renda, vamos utilizar um coeficiente aleatório no preço, utilizando assim $\alpha_ip_i$ no lugar de $\alpha \ln(y_{i}-p_{j})$.  

Como instrumento, vamos utilizar o IPI, e a soma das características (Flex, Gasolina e Cilindradas) entre os modelos da mesma marca e entre os carros de outras marcas. Foi utilizado o pacote do R BLPestimatoR. 
  
Os resultados são mostrados nas tabelas 11 e 12:
  
```{r, include=FALSE, message=FALSE}

J <- nrow(carros_agregado)

Z <- matrix(data = 0, nrow = J, ncol = 6)
for (j in 1:J) {
  
  for (r in 1:J) {
    
    if (carros_agregado$modelo[j] == carros_agregado$modelo[r]) {
      next
    }
    else if(carros_agregado$marca[j] == carros_agregado$marca[r]) {
      Z[j, 1] <- Z[j, 1] + (carros_agregado$combustivel[r] == "Flex")
      Z[j, 2] <- Z[j, 2] + (carros_agregado$combustivel[r] == "Gasolina")
      Z[j, 3] <- sum(Z[j, 3], carros_agregado$cc[r], na.rm = TRUE)
    } else if(carros_agregado$marca[j] != carros_agregado$marca[r]) {
      Z[j, 4] <- Z[j, 4] + (carros_agregado$combustivel[r] == "Flex")
      Z[j, 5] <- Z[j, 5] + (carros_agregado$combustivel[r] == "Gasolina")
      Z[j, 6] <- sum(Z[j, 6], carros_agregado$cc[r], na.rm = TRUE)
    }
    
  }
}

carros_blp <- carros_agregado %>% cbind(Z %>% as.data.frame())

model <- as.formula("sj ~ preco_base + combustivel + cc |
    0 + combustivel + cc |
    preco_base + combustivel + cc |
    0 + ipi + V1 + V2 + V3 + V4 + V5 + V6")


blp_data <- BLP_data(model, 
                     market_identifier = "ano_ref",
                     product_identifier = "modelo",
                     productData = carros_blp,
                     integration_method = "MLHS",
                     integration_seed = 8,
                     integration_accuracy = 50)

blp_estimate <- estimateBLP(blp_data,
                            solver_method = "BFGS", 
                            solver_maxit = 1000, 
                            solver_reltol = 1e-6,
                            standardError = "homoskedastic",
                            printLevel = 1)

(blp_summ <- summary(blp_estimate))

```

```{r, echo=FALSE, message=FALSE}

tibble(blp_summ$LinCoefficients) %>% 
  cbind(" " = c("Intercepto", "preco", 
          "Flex", "Gasolina", "Cilindradas")) %>% 
  select(` `,
         Estimativa = Estimate, 
         `Erro-Padrão` = `Std. Error`, 
         `Estatística-t` = `t value`, 
         `P-valor` = `Pr(>|t|)`) %>% 
  kbl(caption = "BLP - Coeficientes Lineares",
      booktabs = TRUE) %>%
  kable_styling(latex_options = "HOLD_position")

tibble(blp_summ$RcCoefficients) %>% 
  cbind(" " = c("Intercepto", "preco", 
          "Flex", "Gasolina", "Cilindradas")) %>% 
  select(` `,
         Estimativa = Estimate, 
         `Erro-Padrão` = `Std. Error`, 
         `Estatística-t` = `t value`, 
         `P-valor` = `Pr(>|t|)`) %>% 
  kbl(caption = "BLP - Coeficientes Aleatórios",
      booktabs = TRUE) %>%
  kable_styling(latex_options = "HOLD_position")
```
  
Na tabela 11 (Coeficientes Lineares) temos coeficiente negativo para o preço, conforme a teoria esperaria. No entanto, nenhum coeficiente é significante. Na tabela seguinte (Coeficientes Aleatórios) também não temos nenhum coeficiente significativo e o de preço se torna positivo.  
  
# Exercício 9  
  
Vamos refazer os itens 6 e 7 utilizando as estimativas do BLP.  
  
Começando pelo item 6, vamos reestimar as elaeticidades cruzadas para o ano de 2016. Agora, as elasticidades passam a ser dadas por Nevo (2000). Os resultados estão apresentados no gráfico abaixo e, diferentemente do que foi visto no exercício 6, aqui não temos uma relação tão clara de aumento da elasticidade com a quantidade vendida.  
  
No entanto, os resultados aqui não parecem fazer muito sentido, já que a maior elasticidade cruzada para esse ano, com o Gol, foi o IX35, um modelo de carro muito mais caro, que não deveria ser o mais substituto para o Gol dentre todos da amostra.
  
```{r, include = FALSE, message = FALSE, warning = FALSE}

theta1_price <- blp_estimate$theta_lin["preco_base", ]

theta2 <- matrix(NA, nrow = 5, ncol = 1)
colnames(theta2) <- c("unobs_sd")
rownames(theta2) <- c("(Intercept)", "preco_base", "combustivelFlex", "combustivelGasolina", "cc")
for (i in 1:5) {
  theta2[blp_estimate$indices[i, 1], blp_estimate$indices[i, 2]] <- blp_estimate$theta_rc[i]
}


delta_data <- data.frame(
  "modelo" = blp_data$parameters$product_id,
  "ano_ref" = blp_data$parameters$market_id_char_in,
  "startingGuessesDelta" = blp_estimate$delta
)

blp_data <- update_BLP_data(
  data_update = delta_data,
  blp_data = blp_data
)

shareObj <- getShareInfo(
  blp_data = blp_data,
  par_theta2 = theta2,
  printLevel = 1
)

blp_elast <- get_elasticities(
  blp_data = blp_data,
  share_info = shareObj,
  theta_lin = theta1_price,
  variable = "preco_base",
  market = "2016"
)


elast_cruz <- filter(carros_agregado, ano_ref == 2016)
elast_cruz$elasticidade <- -alpha*elast_cruz$sj*elast_cruz$preco_base[elast_cruz$modelo=="GOL"]/1000
elast_blp <- elast_cruz %>% 
  cbind("elasticidade" = tibble(elasticidade = blp_elast["GOL", ]))
elast_blp <- subset(elast_blp, modelo!="GOL",select = c(modelo, quantidade, elasticidade...16, preco_base, sj, marca))
colnames(elast_blp)[3]<-"elasticidade"

```


```{r, echo=FALSE}
#gráfico
ggplot(elast_blp, aes(x=quantidade, y=elasticidade)) + geom_point() + 
  geom_smooth(method=lm, se=FALSE) +
  labs(
  title = "Figure 2: Elasticidade x Quantidade (BLP)",
  subtitle = "2016",
  x = "Quantidade vendida",
  y = "Elasticidade"
) + theme_bw()

```
  
Agora vamos refazer o item 7 e vamos utilizar o mesmo método para calcular o Custo Marginal e foram utilizados os dados agregados. Os resultados estão na tabela 11.  
  
Os markups continuam a ser maiores para os carros de menor preço, no entanto os números são bem menores daqueles encontrados no exercício 7. Os custos marginais estão bem mais próximos dos preços, o que nao é o esperado na realidade.
    
```{r, echo=FALSE, message=FALSE, warning=FALSE}
J <- nrow(elast_blp)

p <- matrix(elast_blp$preco_base, nrow = J)
s <- matrix(elast_blp$sj, nrow = J)

Delta <- matrix(nrow = J, ncol = J)
for (j in 1:J) {
  
  for (r in 1:J) {
    
    if(elast_blp$marca[j] != elast_blp$marca[r]) {
      Delta[j, r] <- 0
    } else {
      Delta[j, r] <- -blp_elast[j, r] * s[j] / p[r]
    }
    
  }
}

c <- c(p - solve(Delta) %*% s)
c_blp <- elast_blp %>% cbind("c" = c)

c_blp %>% 
  mutate(markup = (preco_base/c) - 1) %>% 
  select(marca, modelo, sj, preco_base, c, markup) %>% 
  kbl(col.names = c("Marca", "Modelo", "Sj", "Preço", "Cmg", "Markup"), caption = "Custo Marginal - BLP (2016)",
      booktabs = TRUE) %>%
  kable_styling(latex_options = "HOLD_position")
```

  

# Referências
- Berry, S., Levinsohn, J., & Pakes, A. (1995). Automobile prices in market equilibrium. Econometrica, 841-890.

- Nevo, A. (2000). A practitioner's guide to estimation of random‐coefficients logit models of demand. Journal of Economics & Management Strategy, 9(4), 513-548.
  
- Nevo, A. (2001). Measuring market power in the ready‐to‐eat cereal industry. Econometrica, 69(2), 307-342
